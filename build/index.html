<!DOCTYPE html>
<html>
<head>
	<title>image coloring test</title>
	<style>
	.x{
		position: absolute;
		background: #d8d8d8;
		width: 768px;
		height: 512px;
		transform: translate(25%, 25%);
	}
	/*
	con una posición absoluta, podemos simular una pantalla para mostrar los sprites
	y los datos. El ancho y altura simulan las dimensiones que el campo del juego tendría usualmente
	*/
	.t{
		position: absolute;
		transform: translate(0%, 100%);
	}
	/*
	se usa para la imagen tutorial. Cuando se inicie el programa, se moverá muy abajo
	*/
	.sprite {
		position: absolute;
		transform: translate(50px, 50px);
	}
	/*
	la clase que los sprites tendrán. Se coloca el translate para que se pueda modificar después
	*/
	.slider {
		width: 80%;
	}
	/* clase del deslizador */
	.l {
		width: 5%;
	}
	/* clase de los botones que se encuentran con el deslizador */
	.playdata1 {
		position: absolute;
		font-size: 18px;
		bottom: 36px;
		left: 8px;
	}
	/* clase de los datos del jugador 1 */
	.playdata2 {
		position: absolute;
		font-size: 18px;
		bottom: 36px;
		right: 8px;
	}
	/* clase de los datos del jugador 2 */
	</style>
</head>
<body>
	<div id="x">
	<!--
	en este div se guarda la "pantalla" donde se muestran los sprites, y datos como:
	barra de supercombo
	número de animación actual
	fotograma
	round
	-->
	</div>
	<div id="y" class="slidecontainer">
	  <!--<button onclick="play()" class="l">&#9199;</button>
	  <input type="range" min="1" max="10" value="50" class="slider" id="myRange">
	  <input type="number" id="demo" min="1" max="10" placeholder="1"></input>-->
	  <!--<p>Playing: <span id="play"></span></p>-->
	<!--
	aquí se guardan todos los botones para manejar la repetición, como:
	boton de reproducción
	botónes para moverse fotograma por fotograma
	deslizador de progreso de la repetición
	botones para moverse a diferentes rounds
	-->
	</div>
	<div>
	  <!--
	  este div contiene los datos que se van a mostrar al entrar al sitio
	  -->
	  <span id="loading"></span>
	  <!--aquí se mostrará el progreso de carga del archivo de texto-->
	  <p id="description">
	  <!--se debe colocar todos nuestros elementos dentro de un p con
	  una id específica porque después de que se reciba un archivo, se
	  van a eliminar-->
		<input type="file" id="input"/><br />
		<!--botón para el archivo-->
		<a href="download/replaysaver.lua" download>
		<button>Download the replaysaver script here!</button>
		</a><br />
		<!--aquí se puede descargar el archivo "replaysaver.lua"
		para poder grabar repeticiones que se puedan procesar con
		este programa-->
		<a href="download/list.txt" download="demo.txt">
		<button>Download a demo ready to be replayed</button>
		</a><br />
		<!--
		se da una demostración con varios rompimientos de guardia
		en caso de que el usuario sólo quiera ver el programa en acción
		-->
		Welcome to the guard break detector! In this page, you can see where and at what point did you or your opponent got guardbroken<br />
		Scroll down this page to learn how to use this program<br />
		Note:
		The program only currently works with Wolverine, War Machine, Venom, Red Venom and Golden War Machine
		<!-- 
		cabe destacar que, en este momento, el programa sólo funciona con cinco personajes,
		los cuales son Wolverine, War Machine, Venom, y sus contrapartes secretas,
		Red Venom y Golden War Machine
		-->
		<img src="tutorial/tutorial1.png"></img><br />
		<img src="tutorial/tutorial2.png"></img><br />
		<img src="tutorial/tutorial3.png"></img><br />
		<img src="tutorial/tutorial4.png"></img><br />
		<img src="tutorial/tutorial5.png"></img><br />
		<!--
		estas cinco imágenes explican cómo grabar una repetición y cómo abrirla
		en el programa
		-->
		<h1></h1>
		<!--
		el método para borrar el contenido del p con id "description" es el de
		simplemente equivaler su innerHTML a ''
		document.getElementById('description').innerHTML = '';
		así, la pàgina se deja en blanco.
		Sin embargo, queremos dejar la siguiente imagen: la que explica la interfáz
		del programa, por lo que agregamos un título vacío, para que ya no cuente
		como parte del p y no se borre
		-->
		<img src="tutorial/description.png" id="tutorial"></img><br />
	  </p>
	</div>
	<script>
	var v1,v2,g,r;
	/*
	v1 y v2 son la cantidad de victorias que tiene cada jugador hasta cierto punto
	son usadas exclusivamente para mantener cuenta y nombrar a cada round
	
	g es el estado del juego en el que se encuentra el fotograma actual.
	
	Este analizador procesa una repetición creada con el script replaysaver.lua,
	el cual guarda datos del juego para cada fotograma, incluyendo el estado del juego.
	Los estados del juego que se guardan son los siguientes:
	6 - antes de que empieze el round, donde lo único que pueden hacer ambos jugadores es
	    caminar un poco hacia el otro o caminar hacia atrás
	8 -	el round en sí, donde pasa la pelea
	10- también a en hexadecimal, es el estado del juego donde se noquea al último de los dos
		personajes de un jugador
	12- también c en hexadecimal, es donde se anuncia el ganador. De este estado, 
		sólo se graba el primer fotograma, y no tiene los datos usuales, sino te 
		dice qué numero de round que acaba de terminar, y quién de los dos jugadores
		lo gano
	
	al momento de procesar la repetición, el dato del estado del juego se procesa
	primero, para que se sepa qué se va a leer de él
	
	r es el round en el que nos encontramos ahorita. se usa para saber en qué lista
	de cada una de las listas se van a guardar todos los datos, y de dónde se van
	a extraer al momento de analizarlos con este programa
	*/
	var charids = [];
	var roundlist = [1];
	/*
	charids guarda los nombres de los personajes, los cuales se usan para abrir sus
	sprites desde su carpeta src-rough/nombre. puedes ver todos esos nombres en la 
	línea 478, se guardan en las líneas 917, y se abren en la línea 1569
	
	roundlist no guarda los datos de cada round en sí, sino sólo el último fotograma
	de cada uno. Esos valores se usan para saber de qué fotograma a qué fotograma se
	encuentra cada round, y de ahí, obtener los valores de ciertas listas en la pos-
	ición lista[roundlist[round] - roundlist[round - 1]], ya que esas listas no guar-
	dan sus datos por round, sino por fotograma, entonces no saben en qué round se 
	encuentran, y están guardados en una lista larga, y como esta lista guarda el fo-
	tograma que se esta analizando, y el fotograma no se resetea a 1 cuando se anali-
	za un nuevo round, tenemos que restar el último fotograma del round actual con el
	del round anterior para obtener la cantidad de fotogramas a analizar
	
	para obtener el nombre de un personaje a través de charids, buscamos
	charids[jugador + (round - 1) * 4]
	donde jugador va del 0 al 3, los personajes del jugador 1 están guardados en 0 y 2
	y los del jugador 2 en 1 y 3
	y donde round es el round actual. Vale la pena destacar que los rounds empiezan
	desde 1 y no desde 0, por eso se necesita restarle 1 al principio, pero también, es
	por esto que algunas listas tienen una lista vacía o un valor de más, para que ese
	valor en la posición [0] no se lea y empiecen a agregar datos desde el índice [1]
	
	roundlist ya tiene un valor 1 en índice [0] por esto mismo
	*/
	
	var f = 1; //frame
	var l = 5; //current line
	var ff = 1;
	/*
	f es el fotograma que se está analizando de la repetición al momento de generar
	datos para su pronto análisis. Después de que se realice, este dato se ignora
	
	l es la linea actual del archivo de repetición que se está analizando. empieza
	con un valor de 5 porque las primeras 5 lineas (incluyendo linea 0) están res-
	ervadas para otros datos que se muestran en la línea 811
	
	ff es el fotograma del cual se están tomando los datos. este valor no es relativo
	a ningun round, debido a la forma en que las otras listas están acomodadas. 
	*/
	
	var gbs = [[]];
	var pgbs = [[],[],[],[]];
	var stoppingframe = 0;
	
	/*
	aquí se guardan los datos sobre los rompimientos de guardia. sus acronimos son:
	p - possible
	g - guard
	bs- breaks
	
	la primera lista, guard breaks, guarda el jugador cuya guardia fue rota,el primer 
	fotograma donde un jugador salta y el primer fotograma donde ese jugador bloquea, 
	separadas por rounds. La explicación de cómo se rompe la guardia se puede encon-
	trar en la documentación del proyecto, pero la lógica en la programación se ex-
	plica en la línea 994
	
	la segunda lista, possible guard breaks, guarda para cada jugador esos mismos fo-
	togramas, pero a diferencia de gbs, este los guarda mientras los analiza de la
	repetición. Como su nombre lo dice, se usa para ver la posibilidad de un rompi-
	miento de guardia. 
	Esta es de las únicas listas que tiene un tamaño fijo, siendo de 4, conteniendo
	una lista en cada una de esas posiciones que representa a cada uno de los 4 juga-
	dores.
	Cuando la repetición detecta que se alguien está saltando, guarda el fotograma
	donde pasó. Si sucede algo diferente a que bloquee en el aire después de saltar,
	se borra el fotograma. Pero si sí bloquea, se guarda ese mismo fotograma en la lis-
	ta del jugador. 
	Si la lista del jugador tiene el fotograma de salto, el fotograma de bloqueo aereo,
	y después en el fotograma analizandose se encuentra en la animación de caída, 
	entonces ahí sucedió un rompimiento de guardia, y los datos que pgbs ha obtenido se
	los dá a gbs, incluyendo el número de jugador. En caso contrario, se borran los con-
	tenidos de la lista
	*/
	
	var bs = [[]];
	var pbs = [[],[],[],[]];
	
	/*
	Estas listas son una adición reciente. Los bs (o BounceS) suceden cuando un jugador
	rebota en el suelo al ser aventado por el otro de una forma que no resulte en que
	se quede en el suelo un rato como si fuese empujado muy duro. Saber cuándo suceden
	los rebotes es importante porque, en la animación "1c36", la animación donde uno re-
	bota, ese jugador puede atacar. Inmediatamente que tocan el suelo, pueden salir del
	aturdimiento del golpe al entrar a esta animación, y tomar al oponente por sorpresa,
	porque el rebote sucede muy rápido.
	
	Estas dos listas funcionan muy similar a las listas de rompimiento de guardia. Pri-
	mero, por la lista possible bounces, se guarda el primer fotograma donde se sucita
	la animación "1c36", y cuando se sale de esa animación, se guarda en bs: 
	el jugador que acaba de rebotar
	el primer fotograma donde el rebote sucede
	el primer fotograma donde el jugador sale del rebote
	Pero a diferencia del rompimiento de guardia, todos los posibles rebotes se agregan
	a la lista, porque si entras a esa animación, ya no estás en aturdimiento. Si te
	golpean mientras rebotas, ahí esta en tí, y puedes saber si algo así sucedió y donde
	*/
	
	var ucs = [[]];
	var pucs = [[],[],[],[]];
	
	/*
	todavia no se implementa
	*/
	
	var todetect = 0;
	/*
	esta variable nos dice, de las siguientes, cuáles podemos observar en este momento,
	dependiendo de su valor:
	0 - rompimientos de guardia
	1 - rebotes
	2 - uncombos (a implementarse)
	el valor de todetect se puede cambiar con botones que se muestran en la línea 510
	*/
	
	//frame
	var gamestate = [6];
	var validity = [[0,0,0,0]];
	var xpos = [[0,0,0,0]];
	var ypos = [[0,0,0,0]];
	var orientation = [[0,0,0,0]];
	var animid = [["0","0","0","0"]];
	var meter = [[0,0,0,0]];
	var prj = [[]];
	/*
	
	en todas estas listas se guardan los valores que se obtienen de la repetición, y
	están separados por fotogramas. Al igual que el round, el valor del fotograma em-
	pieza desde 1, así que los vlores con los que se empieza acá son los del fotogra-
	ma 0. Si en algun momento se accede a ese fotograma, por lo menos podrán acceder
	a los valores de este.
	
	gamestate guarda el valor del estado de juego del fotograma actual. los estados
	de juego se explican en la línea 85. Si no mal recuerdo, este valor no se muestra
	en este momento en ninguna parte del programa al cual el usuario pueda tener ac-
	ceso, pero vale la pena tenerlo en cuenta
	
	validity guarda el estado de validez del jugador en ese fotograma. 
	Si es 0, o ese jugador está noqueado, o ese jugador se encuentra fuera del campo 
	de batalla, esperando su turno para entrar.
	Si es 1, entonces ese jugador se encuentra peleando.
	La razón de porqué decidí tener esta tabla de validez en lugar de tener una va-
	riable que use menos datos y sólo me diga quién de los dos está peleando, es por
	una mecánica del juego llamada "variable cross", la cual permite ver a ambos per-
	sonajes de un jugador en pantalla al mismo tiempo por un determinado tiempo, así
	que esta era la mejor forma de tomar esa mecánica en cuenta
	
	xpos mantiene la posición en x, ypos la posicion en y, de todos los jugadores
	esta posición puede ser entre 0 y 768 por x, y entre 0 y 472 por y, con algunas
	excepciones, como cuando:
	un jugador sale de la pantalla por la parte superior y termina en la posición 65535
	el juego sucede en el escenario del baño, donde la x se puede extender hasta 1536
	el juego sucede en el escenario del bar, el cual su suelo se encuentra en y = 456
	
	orientation guarda el bit que nos dice hacia donde el jugador ve, y puede ser:
	0 para izquierda
	1 para derecha
	en ocasiones selectas, por ejemplo cuando estas siendo agarrado, la orientación
	puede ser 2 o 3, así que en realidad se checa si el jugador mira a la izquierda o
	derecha con la formula orientation[jugador] % 2
	
	animid guarda el id de animación del jugador. Esta es la única lista que guarda sus
	datos como cadenas en vez de números, y hay 2 razones para ello:
	
	para mostrarlas como hexadecimales, porque de ese modo, podemos saber qué tipo de
	animación se encuentra el jugador, el cual se muestra por los primeros 2 números.
	Algunos ejemplos de tipos de animación son:
	1c - el jugador esta lastimado
	22 - estan agarrando al jugador
	2e - el jugador està realizando un super movimiento
	
	la segunda razón es para que se use para abrir la imagen de la animación de la
	carpeta src-rough, y se pueda sumar fácilmente al directorio
	"src-rough/nombre/orientación/animación.png"
	
	meter guarda la cantidad de barra de super combo que tiene cada jugador. Cada
	jugador guarda su valor de supercombo, pero sólo se muestra el del jugador que
	se encuentra activo. Si ambos se encuentran activos, entonces estamos en variable
	cross y sus valores de meter son 0
	
	prj guarda todos los proyectiles que aparecen en el fotograma. Cada fotograma
	tiene guardados sus propias pequeñas listas con los valores:
	jugador
	x
	y
	dentro de la lista en la posición del fotograma, se checan por todas las listas 
	dentro de ella para sacar el valor de todas ellas
	*/
	document.getElementById('input')
	.addEventListener('change', function(e){
	/*
	es en este lugar donde se procesa el documento de la repetición. Se abre desde un
	botón donde puedes subir el archivo. Sabríamos que es el archivo de repetición si
	empieza con una @ y con nada más. Para saber cómo está estructurada la repetición,
	revisese el programa de lua "replaysaver.lua"
	*/
		var file = e.target.files[0];
		/*
		esta función sólo se activa cuando se sube un archivo, pero sólo puede detectar
		el primer archivo que se sube. Por lo que si se sube un archivo erróneo, se tiene
		que recargar la página para volver a intentar subir un archivo
		*/
		if (!file) {
			return;
		}
		//si no se subio nada, deja de leer el código, y no tienes que recargar la página
		//para volver a intentar subir algo
		var reader = new FileReader();
		reader.onload = function(e) {
			var contents = e.target.result;
			if(!e.target.result) return;
			/*
			estas 4 funciones nos permiten leer el archivo que subimos
			
			primero, creamos un nuevo lector de archivos con la función FileReader
			algo así como creamos una imagen
			después, cuando cargue el archivo, ejecutar todas las funciones dentro
			del parentesis
			agarramos los contenidos con e.target.result, y si no hay nada, dejamos
			de ejecutar lo demàs
			*/
			replay = contents.split('\n');
			/*
			como nuestro archivo de la repetición divide todos sus datos por líneas,
			dividimos todo el contenido en una lista por cada vez que el caracter de
			diferente linea, "\n", aparece. Asì, podemos leer el archivo línea por
			línea, como por cada elemento de la lista replay
			*/
			console.log(replay[0]);
			if(isEqual(0, "@")) load();
			/*
			confirmamos que el primer caractér de la lista es una arroba, y si lo es,
			ejecutamos la función load, en donde analizamos todo
			como la primera linea no sería "@" sino "@\n", se realiza la comparación
			con la función "isequal" la cual se explica en la línea 407
			*/
		};
		reader.readAsText(file);
		//aquí leemos el archivo guardado en la variable file
	}, false);
	
	function isEqual(strlist, str1){
		/*
		esta función te dice si una cadena de la lista replay es igual a un caractér dado
		y para hacerlo, se le remueve el caractér "\r", que en realidad es "\n"
		strlist es la posición en la lista replay de donde sacaremos la cadena a comparar
		con la cadena str1, nadamas que sin el \r
		*/
		//if(replay[strlist] == str1 + "\r") return true;
		//return false;
		/*
		esta es la primera versión de la función. aquí, sólo se ve si la cadena de replay
		en la posición [strlist] es igual a str1 màs el enter para ir a otro párrafo, \r
		sin embargo, esta función no toma en cuenta la última línea del archivo de texto,
		el cual no tiene un caractér "\r", y al compararlo con esa cadena,será falso por
		que, por ejemplo, "m\r" no es igual a "m"
		*/
		tmpie = replay[strlist].split("\r");
		return tmpie[0] == str1;
		/*
		esta versión toma en cuenta ambos escenarios. Primero, usamos un split en un valor
		temporal, el cual dividirá la línea entre el caractér y el \r, y después simplemen-
		te se compara con la cadena dada el elemento 0 de la lista temporal.
		Si \r existe, se colocará en la posición 1 y se ignorará
		si no existe, no pasa nada, la lista se pone con longitud 1, como si dividieramos
		por 1, no pasa nada al dividirlo
		*/
	}
	
	function line(pos){
		return parseInt(replay[pos].replace("\r",""));
	}
	/*
	esta función convierte una línea en la posición ps de la lista replay en un número
	replay[pos].replace("\r","")
	primero, removemos el caracter "\r" con nada, quitandolo en el proceso
	parseInt(replay[pos].replace("\r",""));
	después, lo convertimos a entero con parseInt
	*/
	
	function tohex(r){
		return parseInt(r).toString(16);
	}
	/*
	para convertir un número a hexadecimal
	cabe destacar que esta función lo devuelve en forma de caractér, pero es esta forma
	en la que la queremos, porque se usará mas que nada para mostrar la id de animación
	*/
	
	function animr(plyr){
		switch(tohex(animid[ff][plyr])[0] + tohex(animid[ff][plyr])[1]){
			case "1c": return "1cxx";
			case "22": return "22xx";
			case "24": if(tohex(animid[ff][plyr]) == "2400") 
						return "2400";
					   else
						return "24xx";
			default: return tohex(animid[ff][plyr]);
		}
	}
	/*
	devuelve la animación que el jugador plyr tiene en el fotograma actual
	debería de sólo devolver el valor en animid[fotograma][plyr] convertido en hexadecimal
	sin embargo, debido a que hay varias animaciones que no pude extraer, mas que nada
	todas las diferentes animaciones de cuando estás lastimado, cuando estás agarrado, y
	cuando te estás levantando.
	Esas animaciones fueron guardadas en la carpeta como una sola llamadas "1cxx", "22xx",
	y "24xx", y si la animación actual es de alguno de estos tipos, se devuelve su versión
	genérica en vez de la animación actual
	Si no, si se puede devolver la animación completa, y con seguridad se abrirá
	*/
	
	function charidname(id){
		switch(parseInt(id)){
			 case 2: return "War Machine";
			 case 4: return "Captain America";
			 case 6: return "Hulk";
			 case 8: return "Wolverine";
			 case 10: return "Gambit";
			 case 12: return "Venom";
			 case 14: return "Spiderman";
			 case 16: return "Roll";
			 case 18: return "Ryu";
			 case 20: return "Captain Commando";
			 case 22: return "Chun-Li";
			 case 24: return "Jin";
			 case 26: return "Zangief";
			 case 28: return "Strider-Hiryu";
			 case 30: return "Morrigan";
			 case 32: return "Mega Man";
			 case 36: return "Red Venom";
			 case 38: return "Orange Hulk";
			 case 40: return "Golden War Machine";
			 case 42: return "Shadow Lady";
			 default: return "Lilith";

		}
	}
	/*
	en nuestra repetición, sólo se guarda el número de qué personaje se eligió, y no
	su nombre. Para abrir la carpeta necesaria, tenemos que devolver el nombre del
	personaje, y eso hacemos con este switch case, convierte un número en el nombre
	*/
	
	function infobutton(id){
		tmp1 = "";
		/*
		esta función crea botones que te permiten moverte hacia un fotograma donde
		algo importante sucedió, dependiendo del botón que presiones, se crearán
		botones para mostrar rompimientos de guardia, rebotes, entre otros. 
		
		Lo que mostrarán los botones depende del valor de todetect explicado en la
		línea 275
		La explicación sobre el rompimiento de guardias se encuentra en la documen-
		tación pero los datos que se guardan se explican en la línea 212.
		Lo mismo para los rebotes, que se explican en la 245
		
		Los botones se muestran a la izquierda de la pantalla, y al oprimir uno, te
		llevará 60 fotogramas antes del primer fotograma que marca el botón, y se 
		detendrá por su cuenta 60 fotogramas después del segundo. Los números de los
		fotogramas que guardan los botones se obtienen de la lista adecuada depen-
		diendo de lo que diga todetect:
		0 - gbs - lista de rompimientos de guardia
		1 - bs - lista de rebotes
		tomará el dato lista[round][1] y [2], ya que [0] contiene el jugador
		*/
		switch(todetect){ //dependiendo de lo que diga todetect
			case 0: //buscamos rompimientos de guardia
			for(itmp = 0; itmp < gbs[id].length; itmp++){
				/*para cada lista en gbs del round analizandose
				id es el round
				se usa itmp en vez de i porque esta función se usa dentro de otr loop for
				*/
				tmp1 = tmp1 + "<button onclick='gbcheck(" + gbs[id][itmp][1] + "," + gbs[id][itmp][2] + ")'>" + gbs[id][itmp][0] + ": " + gbs[id][itmp][1] + "-" + gbs[id][itmp][2] + "</button><br />";
				/*
				x = gbs[id][itmp]
				donde x es la lista del rompimiento de guardia número itmp para el round dado 
				x[0] - el jugador al cual se le rompió su guardia
				x[1] - el primer fotograma donde el jugador x[0] saltó
				x[2] - el primer fotograma donde el jugador bloquea después de saltar
				
				se crea un botón con la siguiente estructura:
				
				al hacerle click, ejecuta la función gbcheck con las variables x[1] y x[2]
				la explicación de la función se explica en la línea 670
				
				el nombre del botón es "x[0]: x[1] - x[2]", que dice el jugador, y ambos
				fotogramas
				
				los botones se separan por un renglón con br
				
				para los otros casos, se usa una función muy similar a esta
				*/
			}
			break;
			case 1: //buscamos rebotes en este caso
			for(itmp = 0; itmp < bs[id].length; itmp++){
				//buscamos todas las listas en la lista de rebotes bs del round
				tmp1 = tmp1 + "<button onclick='gbcheck(" + bs[id][itmp][1] + "," + bs[id][itmp][2] + ")'>" + bs[id][itmp][0] + ": " + bs[id][itmp][1] + "-" + bs[id][itmp][2] + "</button><br />";
				//creamos botones con la misma estructura
			}
			break;
			default:
			//en el caso default, no se agrega ningún botón
			break;
		}
		document.getElementById("gbselect").innerHTML = tmp1;
		/*
		se lo agregamos al div "gbselect", una sección del programa que todavía
		no se crea, sino hasta la línea 1342, pero es aquí donde se contienen
		todos los botones de los momentos clave. En nuestro for de unas líneas
		atrás, generamos todos esos botones y los separamos por elementos br,
		y esos los agregamos a gbselect
		*/
	}
	
	function changeround(id){
		/*
		esta función se cambia cuando cambia el round. Todos los cambios que buscamos
		realizar cuando sucede son:
		
		regresar al primer fotograma, tanto visualmente como funcionalmente en ff
		regresar el deslizador de reproducción al principio
		ajustar el valor máximo de este de forma que pueda mostrar todos los fotogramas del round
		ajustar el número de round al dado
		detener la reproducción de la repetición
		ajustar stoppingframe a que sea el máximo del deslizador (ver línea 1657)
		crear botones para la situación dicha por todetect para este round
		colorear a los personajes (ver línea 626)
		*/
		//playbutton.innerHTML = false;
		document.getElementById("myRange").value = 1; //se ajusta el valor del deslizador a 1, regresandolo al principio
		document.getElementById("myRange").max = roundlist[id] - roundlist[id - 1] - 1; //su máximo se vuelve la cantidad de fotogramas del round
		currframe.innerHTML = 1; //el número visual de fotogramas se vuelve 1
		ff = 1; //el fotograma funcional se vuelve 1
		currround.innerHTML = id; //el número de round se vuelve el round dado id
		stoppingframe = roundlist[id] - roundlist[id - 1] - 1; //stopping frame se vuelve la cantidad de fotograma
		document.getElementById("play").innerHTML = false; //se detiene la reproducción
		//para saber si se está reproduciendo, se compara con el innerhtml del texto de reproducción,
		//o sea, su innerhtml, y se ve si es falso o verdadero
		/*tmp1 = "";
		if(todetect == 0) for(itmp = 0; itmp < gbs[id].length; itmp++){
			
			tmp1 = tmp1 + "<button onclick='gbcheck(" + gbs[id][itmp][1] + "," + gbs[id][itmp][2] + ")'>" + gbs[id][itmp][0] + ": " + gbs[id][itmp][1] + "-" + gbs[id][itmp][2] + "</button><br />";
		}
		document.getElementById("gbselect").innerHTML = tmp1;*/
		infobutton(id);
		/*
		en la sección comentada, se realiza la adición de rompimientos de guardia que sucedieron
		en el round (si hay), en un tiempo donde se consideró como el único escenario que se iba
		a analizar. Sin embargo, la función infobutton que se puede ver en la línea 510 cumple
		esta función y permite añadir botones para más escenarios
		*/
		//https://codepen.io/sosuke/pen/Pjoqqp
		/*
		la de abajo es la función para colorear a los personajes de rojo o azul, o amarillo o verde
		y para encontrar los colores y poder cambiar los colores entre cada round, los sprites se
		guardaron para que fuesen negros, y se usó un programa creado por Barrett Sonntag que se
		puede encontrar con el´línk encima de este comentario
		*/
		for(ix = 1; ix <= 3; ix+= 2){ //para los jugadores 1 y tres
			switch(charids[ix - 1 + (id - 1) * 4]){
				/*
				la lista se seguirá analizando empezando a contar desde el 0, así que es necesario restarle
				1 al ix de nuestro for
				
				checamos el nombre que nos da el número de jugador (ix-1) más el round dado (id-1) multipli-
				cado por los 4 jugadores que tenemos
				
				todos los nombres de los personajes se guardan en la misma lista, separados por el round
				cabe destacar que el round empieza también desde 1, pero esta lista cuenta desde 0, por
				lo que también se tiene que restar 1
				*/
				case "Red Venom": case "Golden War Machine": case "Orange Hulk": case "Shadow Lady": case "Lilith":
				/*
				en Marvel Vs Capcom, aparte de tener los 15 personajes visibles en el menú de selección de
				personajes, existen personajes secretos que reutilizan los sprites y la mayoría de las anim-
				maciones que sus personajes originales. Para contrastar a un personaje secreto de un perso-
				naje original, al secreto se le coloreará de amarillo para el jugador 1, y al original de
				rojo
				*/
					document.getElementById("Player" + ix).style.filter = "invert(94%) sepia(83%) saturate(3306%) hue-rotate(356deg) brightness(106%) contrast(103%)"; break;
					/*
					comando para cambiar el color del jugador a amarillo. Se checa a qué jugador se le cambió
					el color con el número ix, el cual no se le resta 1 esta vez, porque los jugadores se
					cuentan desde 1 en el html
					*/
				default:
					document.getElementById("Player" + ix).style.filter = "invert(11%) sepia(81%) saturate(5317%) hue-rotate(357deg) brightness(128%) contrast(117%)"; 
					//en caso contrario, se colorea a rojo
				break;
			}
		}
		for(ix = 2; ix <= 4; ix+= 2){ //para los jugadores 2 y 4
			switch(charids[ix - 1 + (id - 1) * 4]){
				/*
				se realiza la misma función para los jugadores 2 y 4, pero intentamos
				colorear para verde o para azul
				*/
				case "Red Venom": case "Golden War Machine": case "Orange Hulk": case "Shadow Lady": case "Lilith":
					document.getElementById("Player" + ix).style.filter = "invert(92%) sepia(61%) saturate(6335%) hue-rotate(104deg) brightness(103%) contrast(105%)"; break;
				default:
					document.getElementById("Player" + ix).style.filter = "invert(8%) sepia(100%) saturate(7485%) hue-rotate(249deg) brightness(103%) contrast(143%)"; 
				break;
			}
		}
	}
	
	function gbcheck(e0,e1){
		/*
		al oprimir un botón generado por infobutton para ver:
		rompimiento de guardias
		rebotes
		etc.,
		realizamos esta función. Lo que buscamos es:
		-mostrar el momento clave un segundo antes de que suceda, y 
		-hacer que se detenga un segundo después
		*/
		tmp2 = [e0,e1];
		tmp2[0] = parseInt(tmp2[0]); tmp2[1] = parseInt(tmp2[1]);
		/*los valores que recibimos para nuestra función son cadenas, así que 
		los valores los convertimos a enteros con estas dos funciones. Para
		no hacer dos valores temporales, hago una lista en su lugar con ambos
		valores recibidos, y a cada valor de la lista, lo convierto individual-
		mente a un número con parseInt
		*/
		document.getElementById("myRange").value = tmp2[0] - roundlist[parseInt(currround.innerHTML) - 1] - 60;
		/*
		para obtener nuestra primer meta, asignamos el fotograma de la repetición a que
		sea el primer valor recibido, el primer fotograma del mometo clave, menos el 
		fotograma donde empieza el round porque la lista gb guarda por fotogramas ab-
		solutos y no relativos al round, menos 60 para marcar el segundo, ya que la repe-
		tición y el juego van a 60 fotogramas por segundo
		*/
		stoppingframe = tmp2[1] - roundlist[parseInt(currround.innerHTML) - 1] + 60;
		/*
		y para obtener nuestra segunda meta, asignamos al valor stoppingframe el segundo
		valor dado, menos el fotograma final del round, MÁS 60, para que se detenga un
		segundo después
		
		mientras se está reproduciendo la repetición, checamos en cada iteración si
		stoppingframe = fotograma al momento, si lo es, la repetición se detiene, y 
		stoppingframe vuelve a ser el valor máximo del round para que no vuelva a
		interrumpir
		*/
		if(stoppingframe > parseInt(document.getElementById("myRange").max))
			stoppingframe = parseInt(document.getElementById("myRange").max);
		/*
		si el fotograma de stoppingframe se pasa los fotogramas que podemos ver, entonces
		regresamos stoppingframe a que sea el valor máximo del deslizador
		*/
		document.getElementById("play").innerHTML = true;
		/*
		empezamos a reproducir la repetición después de que tengamos todo listo
		*/
	}
	
	function load(){
		/*
		esta es la función principal del programa. Después de que subamos nuestra
		repetición al programa y validemos que sea una repetición, ejecutamos es-
		to, donde leeremos toda la repetición y acomodaremos la página, con sus 
		botones y todo, para que la podamos analizar
		
		las funciones que buscamos son:
		
		reproducir la repetición subida por texto 
		poder pausarla o continuar reproduciendo
		moverse fotograma por fotograma sin dificultades
		saltar a cualquier posición del video
		cambiar a cualquier round de la partida
		 al cambiar de round, se busca:
		 volver al principio de la repetición
		 detener la repetición
		moverse a 60 fotogramas antes de un momento clave
		seleccionar qué tipo de momentos clave ver
		 al momento de seleccionar un tipo, generar botones con todos los momentos clave registrados de ese tipo
		mostrar los siguientes datos de atributos:
		 número de round
		 número de fotograma reproduciendose
		 identificador de animación para ambos jugadores activos
		 cantidad de barra de super combo para ambos jugadores
		*/
		/*
		order of reading:

		the validating @
		victoryp1
		victoryp2
		gamestate
		round
		validating word "frame" (and for every frame)
		frame number
		gamestate
		validity number for current player
		either skipping bar "|" or the following: xpos
		ypos
		orientation
		animid
		meter

		if it's gamestate c:
		validating word "frame"
		frame number
		gamestate
		round number that just finished
		who won

		*/
		/*
		aquí traigo la estructura de cómo se verá la repetición del juego
		la explicaré mejor en la versión comentada del script replaysaver.lua
		*/
		
		document.getElementById("x").className = "x";
		/*
		el div "x", donde colocamos los sprites de los personajes, se encuentra
		sin clase al momento de iniciar el programa. Tampoco hay sprites o datos
		mostrables, por lo que esto se hace para que el div x se mantenga invi-
		sible hasta que se suba una repetición
		
		la clase x la coloca en una posición absoluta, le da un fondo gris, y le
		da un tamaño de 768 * 512, el tamaño que el campo completo de juego ten-
		dría usualmente
		*/
		document.getElementById("description").innerHTML = "";
		/*
		este es el comando que utilizamos para borrar todo lo que está dentro del
		div de descripción. Este método permite borrarlo sin necesidad de ponerle
		un id a todo lo que esta dentro de la descripción, pero también, permite
		sólo ciertas partes del texto interno del div de la descripción. Como las
		imágenes y el texto se describen todo por texto, simplemente igualarlo a 
		nada es suficiente para quitarlo
		
		y como se dijo en la línea 121, todo lo que está debajo de un título vacío
		(h1) no se borrará porque ya no pertenece al innerHTML de la descripción
		*/
		document.getElementById("tutorial").className = "t";
		/*
		además de borrar el contenido de la descripción, le damos la clase de t a
		la imagen que sí se va a quedar, la cual es la imágen que explica la inter-
		faz del programa. Se la damos para que tenga una posición absoluta y que
		se encuentre una pantalla en altura abajo de la pantalla del div x
		
		cuando no haya momentos clave en un round dado y por ende no hay botones
		que la empujen más abajo, deberías de poder verla si mueves la pantalla 
		un poco para abajo
		*/
		
		v1= line(1);
		v2= line(2);
		g = (line(3));
		r = 1; //round
		
		/*
		la función línea nos permite obtener el contenido de cada línea de nuestra
		repetición subida. Las primeras 5 líneas contienen información sobre el
		estado de la partida en sí, no de cada round, al momento de empezar a grabar
		la repetición. Estas líneas representan:
		0 - la arroba que confirma si es un archivo de repetición
		1 - el número de victorias de los jugadores 1 y 3
		2 - el número de victorias de los jugadores 2 y 4
		3 - el estado de juego en el que nos encontramos
		
		además, ajustamos r a 1 porque empezaremos desde el primer round
		*/
		
		document.getElementById("loading").innerHTML = "0/" + replay.length;
		/*
		el elemento de progreso de carga se encuentra vacío en este momento, como el
		div de la pantalla x. Ahora que estamos cargando la repetición, colocamos
		(número de líneas leídas) / (número de líneas totales)
		
		cuando el número de líneas leídas sea igual al número de líneas totales, ya
		habremos leído la repetición en su totalidad
		*/
		div = document.getElementById("y");
		/*
		este div también estaba vació cuando empezamos el programa. Aquí se guardarán
		todos los botones y el deslizador necesarios para manejar la repetición. Estos
		botones son:
		
		el botón para moverse a cada round
		para moverse por fotogramas hacia atrás y adelante
		el botón de reproducción y pausa
		el deslizador de reproducción
		los botones para escoger qué tipo de momentos clave veremos
		cada botón para llevarte a cierto momento clave
		*/
		
		failsafe = 500000;
		/*
		si el programa se queda atascado, o el ya no se puede analizar la
		repetición, el siguiente while se detendrá después de quinientos
		mil búcles. Cabe destacar que esto no significa que el programa
		se detiene después de leer 500k líneas, sino después de leer 500k
		fotogramas, ya que es eso lo que lee el siguiente while
		*/
		while(l < replay.length && failsafe > 0){
			failsafe--;
			/*
			mientras haya líneas por leer, y failsafe sea mayor a 0
			
			le restamos 1 a failsafe antes de empezar, como si fuera un for
			como (for failsafe = 500000; failsafe > 0; failsafe--), nada mas
			que este for puede detenerse antes de que lleguemos a ese valor,
			por lo que usamos un while en vez de un for
			*/
			if(isEqual(l, "Frame")){
				/*
				en la repetición, sabemos que nos encontramos analizando un fotograma
				si la palabra "Frame" o fotograma se encuentra en la línea actual dada.
				si la encontramos, ejecutamos lo siguiente
				
				cabe destacar que l es el valor de la línea que se está analizando al
				momento, y que empieza desde 5
				*/
				f = line(l + 1) + roundlist[r - 1] - 1;
				/*
				se guarda el valor del fotograma que se encuentra en la línea l + 1,
				donde l en este momento es la línea donde se encuentra la palabra "Frame"
				
				el valor del fotograma está guardado relativo al round actual, por lo que
				tenemos que aumentarle la cantidad máxima de fotogramas del round anterior
				para que empecemos desde ahí
				*/
				gamestate.push(line(l + 2));
				/*
				se añade a la lista el estado de juego del fotograma dado. Como se dijo en
				la línea 298, esta lísta no tiene uso en este momento, pero vale la pena
				tener a la mano este dato adicional
				*/
				g = line(l + 2);
				/*
				el hecho de que la lista gamestate de estado de juego no se use, no signi-
				fica que no necesitemos saber el estado del juego. le asignamos a g el es-
				tado de juego del fotograma *que se está analizando*, para saber qué lineas
				vamos a tener que leer debajo de frame, y qué acciones tomar
				*/
				l+=3;
				/*
				después de analizar estas 2 líneas, nos saltamos esas líneas, es decir, 
				le añadimos 3 al valor l para que empiece a analizar datos que se en-
				cuentren datos después de estos
				*/
				if(g != 12){
					/*
					si el estado de juego del fotograma analizandose actualmente no es
					12, o c en hexadecimal, significa que el juego continua, por lo que
					es hora de leer los siguientes datos:
					*/
					if(line(l - 2) == 1){
						/*
						si la línea del fotograma es igual a 1, o sea, si acabamos de
						empezar el juego
						*/
						charids.push(charidname(line(l)));
						charids.push(charidname(line(l + 1)));
						charids.push(charidname(line(l + 2)));
						charids.push(charidname(line(l + 3)));
						/*
						empujamos el nombre de todos los personajes. La repetición sólo
						guarda su número de identificación, así que lo procesamos con la
						función charidname que se encuentra en la línea 478
						*/
						l+=4; //nos movemos fuera de las líneas de los personajes
						tmpel = document.createElement("button");
						/*creamos un nuevo botón que se lo asignaremos al div "y" eventualmente
						y se lo asignamos a un valor temporal. Otra ventaja de javascript es
						que podemos declarar variables por primera vez en medio del código y
						en medio de un while*/
						tmpel.value = v1+v2; tmpel.innerHTML = v1 + "-" + v2;
						/*
						este botón será el botón para identificar este round. Su valor será
						la cantidad de victorias del jugador 1 más las del jugador 2 para 
						darnos el número de round, pero empezando desde 0
						
						el nombre del botón, o sea, su innerhtml, mostrará quién tiene cuántas
						victorias al momento de empezar equis round
						*/
						tmpel.onclick = function(){
							changeround(parseInt(this.value) + 1);
						}
						/*
						cuando le hagamos click, activaremos la función "changeround" con el
						valor del botón más 1 (porque empieza desde 0), es decir, cambiamos
						el round al que tenga el valor del botón
						*/
						div.appendChild(tmpel);
						/*
						se lo añadimos al div "y" que se encuentra encima del div "x" de la
						pantalla. Esta función la usaremos muy a menudo para colocar más
						botones y otros elementos
						*/
						gbs.push([]);
						bs.push([]);
						/*
						la última cosa que necesitamos antes de comenzar un round es colocar
						una lista en las lístas de rompimiento de guardia y de rebotes, que
						la relacionemos con este round a analizar
						*/
					} //el primer fotograma también incluye los siguientes datos
					validity.push([]); xpos.push([]); ypos.push([]); orientation.push([]); animid.push([]); meter.push([]); prj.push([]);
					/*
					antes de empezar a analizar el fotograma, agregamos una lista a cada una
					de las siguientes listas, las cuales van a ser relacionadas al fotograma
					actual:
					dato de validez
					posición x
					posición y
					orientación
					identificador de animación
					cantidad de barra de super combo
					proyectiles
					
					algunas listas estarán vacías, como la de los proyectiles, porque ninguno
					se suscitó en este fotograma, pero está bien, porque una lista vacía nos
					hará saber esto, así que de cualquier manera, es necesario añadirlos
					*/
					for(i = 0; i < 4; i++){//para cada uno de los jugadores
						validity[f].push(line(l));//añadimos a la lísta de validez el bit de validez del jugador i
						if(isEqual(l, "1")){ //si ese jugador es válido, o sea, si está jugando en este momento,
							xpos[f].push(line(l + 1)); //añadimos su posición x
							ypos[f].push(line(l + 2)); //su posición y
							orientation[f].push(line(l + 3)); //su orientación, que va del 0 al 3 (ver línea 325)
							animid[f].push(replay[l + 4].replace("\r",""));
							/*
							añadimos su identificador de animación, pero en forma de cadena, como se explicó
							en la línea 327. Realizamos lo mismo que haría la función line que se encuentra 
							en la línea 435, pero sin convertirla en número
							*/
							meter[f].push(line(l + 5)); //y la barra de super combo
							
							switch(tohex(replay[l + 4].replace("\r",""))){
								/*
								en este switch, buscaremos la lógica de rompimientos de guardia
								lo que buscamos se encuentra en la línea 227, y la estructura
								de la lista pgbs se encuentra en la línea 230
								*/
								case "200": case "202": case "204":
								/*
					primero vemos si el jugador está saltando
					la animación de tipo 02 nos dice si el jugador está saltando, pero el
					rompimiento de guardia sólo puede suceder si se realiza un salto normal
					esos saltos normales son:
					200 - salto normal en posición neutral
					202 - salto hacia adelante
					204 - salto hacia atrás
					
					si saltamos, y ninguno de los otros 2 escenarios ha sucedido, 
					entonces empujamos a la lista pgbs del jugador el fotograma 
					donde esto sucedió
								*/
									if(pgbs[i].length == 0){
									//si la lista del jugador no tiene nada, esto es lo primero que sucede
										pgbs[i].push(f);
									}
								break;
								case "c04": case "e04":
								/*
					la animación c04 se da cuando el oponente bloquea en el aire, y
					la animación e04 se dá cuando el oponente bloquea en el aire y
					empuja al oponente con la mecánica "pushblock" para sacarse al
					oponente de cerca suyo. Sin embargo, si saltas normalmente y 
					realizas esto, romperás tu propia guardia no importa lo que hagas,
					por lo que esta es una mecánica riesgosa
					
					si estas haciendo alguno de estos bloqueos, y la longitud de la 
					lista del jugador es 1 (significando que el oponente ha saltado 
					antes), agregamos el fotograma donde el jugador bloqueó
								*/
									if(pgbs[i].length == 1){
										pgbs[i].push(f);
									}
								break;
								/*
					cuando bloqueas, te quedas en aturdimiento por bloqueo por un rato.
					cuando sales de este aturdimiento, dejas de bloquear. si saltaste
					normalmente y bloqueaste en el aire, cuando salgas del aturdimiento,
					ya no podrás volver a bloquear hasta que entres al suelo
					
					si entras a esta animación, y la longitud de la lista pgbs del jugador
					es igual a 2, significando que has saltado, y subsequentemente has
					bloqueado, entonces significa que tu guardia se ha roto
					
					cuando detectamos que tu guardia se ha roto, entonces le añadimos una
					lista a los rompimientos de guardia, gbs, del round analizándose, con
					esta estructura:
					0 - número de jugador
					1 - fotograma donde el jugador saltó
					2 - fotograma donde el jugador bloqueó en el aire
					
					después de esto, o incluso si la animación pasó mientras la longitud
					de la lista del jugador no sea 0, entonces vaciamos la lista. Podemos
					ir de la animación de salto a 212 por varias razones aparte de que
					se haya roto tu guardia, por razones que hablaremos unas cuantas líneas
					adelante, por lo que en cualquier caso que se suiscite la animación
					212, vaciaremos la lísta
								*/
								case "212":
								if(pgbs[i].length == 2){
										gbs[r].push([i, pgbs[i][0], pgbs[i][1]]);
									}
									pgbs[i] = [];
								break;
								/*
					en caso de que se suscite otra animación, comprobamos que alguna de las
					siguientes condiciones se de:
					estás en el suelo
					el tipo de animación sea de que estás lastimado
					
					los rompimientos de guardia son imposibles en el suelo, y si te lastiman
					en el aire, cuando te salgas del aturdimiento de golpe, entrarás en un
					estado donde puedes bloquear más de una vez antes de entrar al suelo, lo
					que hacen los rompimientos de guardias imposibles una vez que un golpe
					encadene
					
					para saber que estás en aturdimiento por golpe, buscaremos si el tipo de
					animación del jugador es del de "1c" al ver sus primeros dos caracteres
					
					para saber si está en el suelo, solo preguntamos su posición en y, y si 
					es 472, entonces está en el suelo. Hay un escenario donde el suelo puede
					ser 456, así que también se toma en cuenta
								*/
								default: 
									if(line(l + 2) == 472 || line(l + 2) == 456 || tohex(replay[l + 4].replace("\r",""))[0] + tohex(replay[l + 4].replace("\r",""))[1] == "1c")
										pgbs[i] = [];
								break;
							}
							switch(tohex(replay[l + 4].replace("\r","")) ){
								/*
								en este switch, identificaremos todo rebote posible, y si
								sucede uno en este fotograma. La lógica de los rebotes es
								más sencilla que la de los rompimientos de guardia, sólo
								necesitamos ver que lleges a la animación "1c36" específi-
								camente.
								
								Sólo se puede llegar a esta animación cuando aterrizas al
								suelo por ser atacado con un combo aereo de uno o dos
								golpes. En cuyo caso, no se quedará en el suelo, y entonces
								rebotará del suelo. Pareciera que todavía está lastimado
								aquí, asta se ve que el tipo de animación es el de "1c" que
								significa que estás lastimado, pero en esta animación,
								puedes cancelarla con cualquier ataque o bloquear, escen-
								cialmente significando que ya no estás lastimado, y si
								puedes identificar cuándo sucede, puedes tomar por sorpresa
								a tu oponente con un ataque que alcanze a tu oponente
								mientras estás rebotando. Por esto es importante tomar en
								cuenta a los rebotes
								
								si vemos que estamos en la animación "1c36", y esta es la
								primera vez que lo tenemos, empujamos el fotograma donde
								sucedió esto en la lista de posibles rebotes
								*/
								case "1c36":
									if(pbs[i].length == 0){
										pbs[i].push(f);
									}
								break;
								/*
								cuando otra animación suceda, si la longitud de la lista pbs
								del jugador es 1, significa que han salido del rebote. No com-
								probamos otra cosa porque si entras a 1c36, ya hubo un rebote.
								
								agregamos la lista con los siguientes elementos:
								0 - jugador que rebotó
								1 - fotograma donde se entra al rebote
								2 - fotograma donde sale del rebote
								
								en cualquier caso, se vacía la lista de pbs del jugador
								*/
								default:
									if(pbs[i].length == 1){
										bs[r].push([i, pbs[i][0], f]);
									}
									pbs[i] = [];
								break;
							}
							l+=6; //nos movemos adelante de las líneas con los datos que analizamos en la línea 983
						}
						else{ //si el jugador no está en el campo de batalla, colocamos valores por default
							xpos[f].push(0);
							ypos[f].push(0);
							//posición x y son 0
							orientation[f].push(0);
							//la orientación no importa
							animid[f].push("12808");
							//la animación 3208 en hexadecimal se da cuando un personaje sale del escenario y se lo deja a su compañero
							meter[f].push(0);
							//barra de super combo vacía
							l+=1;
							//en la repetición, no hay nada más sobre el personaje guardado más que el hecho de que está guardado
						}
					} //después de checar los datos de todos los jugadores en este fotograma
					while(l < replay.length && failsafe > 0 && !isEqual(l,"|")){
					/*
					aquí vemos si hay proyectiles en este fotograma para los pri-
					meros jugadores. ponemos las mismas condiciones que el while 
					general de la lectura de la repetición, además de una condi-
					ción adicional si lo que dice la linea l es "|" (barra ver-
					tical), significa que el primer jugador ya no tiene proyecti-
					les que mostrar 
					
					si no es, entonces hay un proyectil. En respuesta a esto, aña-
					dimos a la lista de proyectiles de ese fotograma una lista:
					0 - de quién es el proyectil
					1 - posición x
					2 - posición y
					
					todos los proyectiles tienen la misma altura y mismo ancho en este
					programa, por lo que en la repetición, no se guardan
					*/
						failsafe--;
						prj[f].push([line(l),line(l + 1), line(l + 2)]);
						l+=3; //nos movemos adelante de estas´líneas, y volvemos a hacer el while
					}
					l+=1;
					//nuestra última línea debería ser la línea con un "|", así que nos la saltamos
					while(l < replay.length && failsafe > 0 && !isEqual(l,"|")){
					//volvemos a hacer todo el proceso, peor para el jugador 2
						failsafe--;
						prj[f].push([line(l),line(l + 1), line(l + 2)]);
						l+=3; //nos saltamos las líneas que ya hayamos identificado y los proyectiles que ya añadimos
					}
					l+=1;
					//volvemos a saltarnos la línea con "|"
				}
				else{ //si sí ya estamos en un fotograma cuyo estado de juego es c:
					r++;
					//ajustamos el round en el que estamos
					if(line(l + 1) == 0) v1++;
					else if(line(l + 1) == 1) v2++;
					//vemos quién ganó, dependiendo de los valores de victoria y derrota, y la línea debajo del número de round
					//en caso de empate, no hacemos nada
					l+=2; //nos saltamos ambas líneas
					roundlist.push(f);
					/*como ya llegamos al final del round, como resultado de estar en estado 
					de juego c, empujamos el último fotograma en el que nos encontramos para 
					añadirlo como el máximo de fotogramas del round
					*/
				}
			}
			else l++; //si no encontramos la palabra "Frame" de validez, nos movemos a la siguiente línea
			document.getElementById("loading").innerHTML = l + "/" + replay.length;
			//la encontremos o no, mostramos nuestro progreso en la cantidad de líneas leídas
		}
		if (g != 12) roundlist.push(f);
		//al leer todas las líneas, agregamos por última vez el número de round, en caso de que no se haya llegado a estado de juego c
		tmpel = document.createElement("br"); //creamos un br para pasar a otro renglón
		div.appendChild(tmpel); //yy se lo agregamos a y
		/*
		en el renglon debajo de los botones de round, agregaremos los siguientes botones:
		
		moverse un fotograma hacia atrás
		pausar/reproducir
		moverse un fotograma hacia adelante
		deslizador que muestra el progreso de la repetición
		*/
		tmpel = document.createElement("button"); 
		/*a todo se lo vamos a asignar a tmpel. Aquí creamos el botón para moverse un 
		fotograma hacia atrás*/
		tmpel.className = "l"; tmpel.innerHTML = "<-";
		/*
		lo único que hace la clase l es darle una anchura del 5% de la pantalla
		su innerHTML será su nombre, y se verá como una flecha hacia atrás para
		demostrar que es la flecha para moverse un fotograma hacia atrás
		*/
		tmpel.onclick=function(){ //1 frame less
			slider.value = parseInt(slider.value) - 1;
			/*
			al hacerle click al botón, nos moveremos un fotograma hacia atrás
			cabe destacar que usamos el valor del deslizador como guía para
			saber en qué fotograma nos encontramos en este momento
			*/
			playbutton.innerHTML = false; //además, detenemos la reproducción de la repetición
		}
		div.appendChild(tmpel); //agregamos el botón a y
		tmpel = document.createElement("button"); //y creamos otro, ahora para el botón de pausar y reproducir
		tmpel.onclick=function(){ //play
			if(playbutton.innerHTML == "false") playbutton.innerHTML = true;
			/*
			a esto me refería con el hecho de que trabajamos con el texto del botón de play. Esta es
			la forma en que me enteré que innerHTML es el texto que tiene un elemento de html en vez
			de su valor. Como es texto, debemos compararlo como tal. Si el botón playbutton dice
			"false" específicamente, lo cambiamos a true
			*/
			else playbutton.innerHTML = false; //en caso contrario, lo cambiamos a false
			if(parseInt(slider.value) >= parseInt(slider.max)) slider.value = 1;
			/*
			si intentamos resumir la reproducción y ya estamos al final de ella, automáticamente vol-
			veremos al principio, al primer fotograma
			*/
		}; tmpel.innerHTML = "&#9199;"; tmpel.className = "l";
		/*
		no sé porqué puse estos dos elementos aquí, pero no hace mucha diferencia.
		la clase l sólo le da una anchura de 5%
		su text es un emoji en un formato que lo pueda procesar html, y es el formato
		de reproducción y pausa. No puedo ponerlo en los comentarios de este programa,
		así que va a tener que buscar en google &#9199;
		*/
		div.appendChild(tmpel); //se lo agregamos
		tmpel = document.createElement("button");
		/*
		y hacemos un nuevo botón para moverse un fotograma hacia atrás
		debemos de crear un botón cada vez porque si no lo hacemos, el programa
		asignará todo al mismo botón
		*/
		tmpel.className = "l"; tmpel.innerHTML = "->";
		/*
		otro botón para la clase l, y mostrará una flecha que se mueve hacia adelante
		*/
		tmpel.onclick=function(){ //1 frame more
			slider.value = parseInt(slider.value) + 1; //al hacerle click, nos movemos un fotograma hacia adelante
			playbutton.innerHTML = false; //y detenemos la reproducción
		}
		div.appendChild(tmpel); //se lo agregamos al div y
		
		tmpel = document.createElement("input"); //slider
		//y ahora hacemos el deslizador, ahorá será del tipo "input"
		tmpel.type = "range"; 
		//para saber que será un deslizador, le decimos que es del tipo "range"
		tmpel.min = "1"; tmpel.max = roundlist[1] - 2;
		/*
		un rango necesita un valor mínimo y un valor máximo, para saber de donde a donde
		iría
		
		el mínimo será 1, el primer fotograma. Recordemos que contamos los fotogramas
		empezando desde 1, no 0
		
		el máximo será el máximo de fotogramas que el round puede tener, en este caso,
		el del round 1
		*/
		tmpel.className = "slider"; tmpel.id="myRange"; tmpel.value="1";
		/*
		le damos la clase "deslizador", que le da un ancho de 80% de la pantalla
		el deslizador, junto con sus 3 botones, acumulan 95% de la pantalla, dejando
		5% de la pantalla libre
		
		le damos una id para que podamos obtener su valor 
		
		y su valor inicial será 1, el principio de la repetición
		*/
		div.appendChild(tmpel); //lo agregamos
		tmpel = document.createElement("br"); //creamos un br para hacer otro párrafo
		div.appendChild(tmpel); //se lo agregamos
		tmpel = document.createElement("button"); 
		/*
		y creamos un botón, esta vez para crear botones que mostrarán cada uno de los
		rompimientos de guardia que sucederán en este round, y se encuentra un renglón
		debajo del deslizador y botones de reproducción
		*/
		tmpel.innerHTML = "Guardbreaks";
		//nombramos el botón "guardbreaks" que es rompimientos de guardia en inglés
		tmpel.onclick=function(){
			todetect = 0;
			infobutton(parseInt(document.getElementById("round").innerHTML));
		}
		/*
		al hacerle click, ajustamos el valor todetect a 0, y activamos la función 
		infobutton con el valor del round actual (guardamos el valor del round en
		un texto que vemos y explicamos en la línea 1509).
		
		Recordemos que la función, infobutton, que se encuentra en la línea 510,
		genera los botones para mostrar todos los momentos clave de un tipo que se
		determina por el valor todetect. Si todetect es 0, entonces mostrará todos
		los rompimientos de guardia
		*/
		div.appendChild(tmpel); //lo agregamos otra vez al div y
		tmpel = document.createElement("button"); //y creamos otro botón, ahora para los rebotes
		tmpel.innerHTML = "Bounces"; //hacemos lo mismo, le damos su nombre
		tmpel.onclick=function(){ //y al hacerle click
			todetect = 1; //ajustamos todetect a 1
			infobutton(parseInt(document.getElementById("round").innerHTML));
			//y ejecutamos infobutton con el round actual. como todetect es 1, creará botones para ver los rebotes
		}
		div.appendChild(tmpel); //lo agregamos al div
		
		tmpel = document.createElement("p"); //y hacemos un nuevo párrafo
		tmpel.id = "gbselect";
		/*
		este párrafo tendrá la identificacíon de gbselect. Como explicamos en la línea
		572, es el contenedor donde colocaremos todos los botones para seleccionar cada
		momento clave. Le damos una id para que los podamos añadir con la función
		infobutton
		*/
		div.appendChild(tmpel);
		//no necesitamos agregarle mucho a este elemento p, así que lo agregamos
		
		tmpel = document.createElement("p"); //hacemos otro párrafo, esta vez para mostrar si está reproduciendose la repetición
		tmpel.id = "tmpel"; tmpel.innerHTML = "Playing: ";
		//le damos una id porque la vamos usar en cotro, y su texto díra "Playing: " y veremos por qué en un segundo
		div.appendChild(tmpel); //se lo agregamos al div y
		div = document.getElementById("tmpel"); //y ahora, asignamos div al elemento p que hicimos
		tmpel = document.createElement("span"); //creamos un texto que podremos modificar, un elemento span
		tmpel.id = "play";
		/*
		aquí pondremos el texto que nos dice si la repetición se está reproduciendo o no
		le damos una id de play para que podamos tener este dato a la mano
		*/
		div.appendChild(tmpel); 
		/*
		lo agregamos al elemento p que creamos en la línea 1352
		en la pantalla, se verá si estamos reproduciendo la repetición con textos como estos
		
		Playing: false
		
		Playing: true
		
		donde la primera parte es el p que hicimos, y el booleano es el span
		*/
		
		var slider = document.getElementById("myRange");
		var playbutton = document.getElementById("play");
		/*
		guardamos la dirección del deslizador y del valor de reproducción en las
		variables slider y playbutton por conveniencia
		*/
		playbutton.innerHTML = false; //detenemos la reproducción por default
		
		slider.oninput = function() {
		  playbutton.innerHTML = false;
		}
		/*
		al hacerle click al deslizador para ir a cualquier parte de la reproducción,
		detendremos la reproducción en automático
		*/
		div = document.getElementById("x");
		for(i = 1; i <= 4; i++){
			/*
			para cada jugador, empezando desde el 1 para identificar que son
			los jugadores del 1 al 4
			*/
			tmpel = document.createElement("img");
			/*
			aquí agregamos los sprites de cada jugador a la pantalla de div x. creamos
			un elemento de imagen, y se lo asignamos a tmpel
			*/
			tmpel.id = "Player" + i;
			/*
			la id luciría algo así: Player1, Player2, Player3, Player4
			*/
			//tmpel.src = "src/Wolverine1/0x113b38.png";
			/*
			al inicio del proyecto, se planeaba que los personajes estuviesen completamen
			te animados, pero porque eran muchas imágenes para poco tiempo, así que decidí
			sólo usar una imagen que representara a cada animación, y guardarla en la
			carpeta src-rough/personaje
			*/
			tmpel.className = "sprite";
			/*
			la clase "sprite" le da una posición absoluta a nuestro personaje en la repetición,
			para que se pueda representar su posición en la pantalla bien
			*/
			div.appendChild(tmpel);
			/*
			se lo agregamos a x, el cual es el div de la pantalla para los personajes.
			Los botones se encuentran encima del div x, y el tutorial debajo
			*/
		}
		div = document.getElementById("x");
		for(i = 0; i < 50; i++){
			/*
			los proyectiles pueden estar en cualquier momento, pero la forma
			en que estructuré este programa no me permite crear estancias para
			cada una el momento que se aparezcan, así que lo mejor que queda
			es crear 50 imágenes para ellos, y mantenerlas invisibles hasta que
			haya un proyectil en este fotograma
			*/
			tmpel = document.createElement("img"); //creamos la imagen
			tmpel.id = "prj" + i; 
			/*
			le agregamos una identificación de la forma "prji" para saber 
			exactamente qué proyectil se está manejando
			*/
			tmpel.className = "sprite";
			/*
			como los proyectiles suceden dentro del juego, debemos darle 
			también la clase de "sprite", para que tenga posición absoluta
			*/
			tmpel.src = "src-rough/p.png"; //tomamos la imagen que vamos a utilizar para los proyectiles
			tmpel.style.visibility = "hidden"; //y los escondemos todos hasta nuevo aviso
			
			div.appendChild(tmpel); //lo agregamos también a la pantalla gris
		}
		
		tmpel = document.createElement("p"); 
		/*
		todavía dentro de x, agregamos un elemento p adicional, donde colocaremos
		la información sobre la ronda y los fotogramas
		*/
		tmpel.innerHTML = ("<p>Round: <span id='round'></span></p><p>Frame: <span id='frame'></span></p>");
		/*
		con una estructura similar a la información de playbutton, se mostrará la
		etiqueta, y junto, estará un span con id "frame" o "round" donde pondremos
		el valor del fotograma o del round. Ambas etiquetas están separadas por 
		elementos p, y como no tienen clase, se colocarán en la parte superior
		izquierda del div x
		*/
		div.appendChild(tmpel); //se lo añadimos a x
		tmpel = document.createElement("p");
		/*
		y creamos otro elemento p. Aquí, se colocarán elementos que nos permitirán
		leer los datos del jugador 1
		
		estos datos pueden cambiar, le puedo añadir más datos que podamos leer, pero
		por ahora, los datos que podemos ver son el tipo de animación y la cantidad
		de barra de super combo
		
		estos datos no se pueden ver acá, al contrario del round y fotograma que 
		agregamos unas cuantas líneas atrás, porque no necesitamos leer esos datos
		para otras funciones, al contrario de ellos, y porque pueden cambiar con
		futuras versiones
		*/
		tmpel.className = "playdata1";
		/*
		la clase playdata1 hace que nuestro elemento p se coloque al fondo a la
		izquierda de la pantalla, además de que la mueve a una posición donde se
		pueda ver bien dentro de ella, y le da una fuente de texto de 18 pixeles
		*/
		tmpel.id = "data1"; //le damos su id
		div.appendChild(tmpel); //y se la agregamos a la pantalla de div x
		tmpel = document.createElement("p"); //creamos otro elemento p
		tmpel.className = "playdata2";
		/*
		le damos su clase. La razón de porqué tuvimos que repetir todo el proceso 
		dos veces en vez de hacer un for es por esto. La clase playdata2 hace
		la mayoria de lo mismo que playdata1, pero en vez de colocarlo a la
		izquierda, lo coloca a la derecha. En CSS, se tiene que escribir en los
		atributos de la clase "left" o "right" dependiendo de qué lado quieres el
		elemento, por lo que tenemos que hacer diferentes clases para ambos elementos p
		*/
		tmpel.id = "data2"; //le damos su id
		div.appendChild(tmpel); //y lo agregamos a x
		sp = [0,0,0,0];
		sp[0] = document.getElementById("Player1");
		sp[1] = document.getElementById("Player2");
		sp[2] = document.getElementById("Player3");
		sp[3] = document.getElementById("Player4");
		/*
		agregamos la dirección de cada sprite de jugador a una lista sp, para que podamos
		acceder a x jugador desde sp[x], y para que podamos hacer fors con ellos
		*/
		//https://codepen.io/sosuke/pen/Pjoqqp
		
		currframe = document.getElementById('frame');
		currround = document.getElementById('round');
		/*
		también asignamos el fotograma en el que nos encontramos a currframe, y el round
		a currround
		
		a diferencia de los demás valores, siempre agarramos el valor del round directa-
		mente de su fuente visual, usando el texto
		parseInt(currround.innerHTML) - 1
		
		puede incluir el -1 o no, dependiendo de si necesitamos contar desde 0 o 1
		
		hay veces donde necesitamos este valor, pero la variable currround no está 
		todavía definida, por lo que tenemos que obtenerla directamente de html
		
		parseInt(document.getElementById("round").innerHTML) - 1
		
		la variable "r" se usó para el análisis de la repetición, y ya no se usará
		para el resto
		*/
		changeround(1);
		/*
		hacemos las funciones de cambio de round, las cuales nos preparan para empezar
		el programa. Estas funciones se encuentran en la línea 582, y son:
		ajustar el valor máximo del deslizador a la longitud del round
		volver al primer frame:
		  ajustar el valor del deslizador a 1
		  ajustar ff a 1, el valor del fotograma actual durante la fase de reproducción
		  ajustar el valor escrito del fotograma a 1
		ajustar el round al primero
		ajustar el valor stoppingframe al del máximo del deslizador
		ejecutar la función infobutton con el primer round
		colorear a los jugadores
		*/
		
		setInterval(function(){
			/*
			realizamos un intervalo, que se eecute 60 veces por segundo, la misma velocidad
			que tiene el juego, así que irá a la par del juego. Aquí, buscamos realizar las
			siguientes funciones:
			
			preparar a los jugadores
			mostrar los proyectiles
			escribir datos especiales para ambos jugadores
			avanzar la repetición por un fotograma si se encuentra reproduciendo
			detenerla si stoppingframe es igual al valor del deslizador
			ajustar el valor de ff y del fotograma visual al del deslizador
			detener la repetición si llegamos al final de ella
			*/
			for(i = 0; i < 4; i++){ //para cada uno de los cuatro jugadores
				if(validity[ff][i] == 1){
					/*
					si su validez es 1 en la tabla de validez[fotograma][jugador], entonces
					ese jugador se encuentra en pantalla en este momento. tenemos que ajustar
					su posición x,y del fotograma en el que se encuentra, y cambiar su pose
					dependiendo de su animación
					*/
					sp[i].style.visibility = 'visible'; //mostramos su imagen como visible, el valor predeterminado es que está escondido
					sp[i].style.transform = "translate(" + (xpos[ff][i] - sp[i].width/2) + "px, " + (ypos[ff][i] - sp[i].height) + "px)";
					/*
					movemos el sprite a su posición x,y
					
					cabe destacar que javascript dibuja las imagenes de los personajes de
					izquierda a derecha del punto x, y de arriba hacia abajo del punto y,
					de esta forma, el punto de posición de la imagen se encuentra en su 
					parte superior izquierda. Para que la imagen se muestre en una posición
					más precisa como se muestra en el juego, tenemos que mover el punto
					hacia en medio de ellos por su x, y abajo de ellos en su y, o sea,
					por en medio de sus pies
					
					para eso, dibujamos la imagen un poco más a la izquierda igual a su anchura
					entre 2 (para que el punto se ajuste en medio por su x, y hacia arriba
					igual a su altura (para que pongamos el punto debajo de la imagen)
					*/
					try{
					sp[i].src = "src-rough/" + charids[i + (parseInt(currround.innerHTML) - 1) * 4] + "/" + orientation[ff][i] + "/" + animr(i) + ".png";
					} catch{
						sp[i].src = "src-rough/" + charids[i + (parseInt(currround.innerHTML) - 1) * 4] + "/" + orientation[ff][i] + "/0.png";
					}
					/*
					como se explicó en la línea 337, obtenemos la imagen que vamos a usar en este fotograma
					para cada jugador i con el nombre del personae que guardamos en la lista charids, el
					número de animación, y la orientación. No hay forma de cambiar de lado una animación 
					en javascript, por lo que se tuvo que hacer imagenes para ambas orientaciones
					
					se añade un try catch en caso de que la animación no se encuentre en nuestra carpeta, y
					si no está, mostramos la imágen de parado determinada, animación 0
					*/
				}
				else{
					/*
					si el bit de validez del jugador es 0, entonces ese jugador no se encuentra
					en pantalla, por lo que ocultamos la imágen de su sprite
					*/
					sp[i].style.visibility = 'hidden';
				}
			}
			for(i = 0; i < 50; i++){
			/*
			para cada uno de los proyectiles
			
			en marvel vs capcom, puede haber hasta 50 proyectiles en pantalla al mismo tiempo, pero no
			podemos crear una imágen cada vez que se presente un proyectil, así que, en la línea 1423,
			creamos 50 imagenes para cada proyectil, todas escondidas al comenzar
			
			cuando haya un proyectil en este fotograma, hacemos un proyectil visible, y lo movemos
			a su posición x,y
			
			nota que todos los proyectiles se ven iguales, ya que no tuve tiempo de guardar todos
			los proyectiles para que se puedan diferenciar. Este efecto se puede ver más con cosas
			como los ataques de War Machine, donde su puño ligero aereo se considera como proyectil,
			pero se encuentra en la misma posición x,y del jugador, por lo que al hacerlo, aparece
			por sus pies, aunque su puño se encuentre mucho más arriba
			*/
				if(prj[ff][i] != undefined){ //si existe un proyectil en la posición prj[fotograma][i]
					document.getElementById("prj" + i).style.visibility = "visible";
					//hacemos visible un proyectil
					document.getElementById("prj" + i).style.transform = "translate(" + (parseInt(prj[ff][i][1]) - 42) +  "px, " + (parseInt(prj[ff][i][2]) - 42) + "px)";
					//y lo movemos a su posicion x,y en la pantalla, menos su anchura y altura sobre 2, para su posición se encuentre en medio
					if(prj[ff][i][0] == "0" || prj[ff][i][0] == "2"){
					/*
					coloreamos al proyectil dependiendo de a qué jugador le pertenece
					el número de jugador en la lista de proyectil se guarda desde el 0,
					entonces los jugadores 1 y 3 del primer equipo son el jugador 0 y 2
					
					cuando sea de alguno de ellos, lo coloreamos rojo
					*/
						document.getElementById("prj" + i).style.filter = "invert(11%) sepia(81%) saturate(5317%) hue-rotate(357deg) brightness(128%) contrast(117%)";
					}
					else{ //caso contrario, serán azules
						document.getElementById("prj" + i).style.filter = "invert(8%) sepia(100%) saturate(7485%) hue-rotate(249deg) brightness(103%) contrast(143%)";
					}
				}
				else{
					document.getElementById("prj" + i).style.visibility = "hidden";
				}
			}
			
			if(validity[ff][0] == 1) document.getElementById("data1").innerHTML = "Meter: " + tohex(meter[ff][0]) + "<p>Animid: " + tohex(animid[ff][0]) + "</p>";
			if(validity[ff][1] == 1) document.getElementById("data2").innerHTML = "Meter: " + tohex(meter[ff][1]) + "<p>Animid: " + tohex(animid[ff][1]) + "</p>";
			if(validity[ff][2] == 1) document.getElementById("data1").innerHTML = "Meter: " + tohex(meter[ff][2]) + "<p>Animid: " + tohex(animid[ff][2]) + "</p>";
			if(validity[ff][3] == 1) document.getElementById("data2").innerHTML = "Meter: " + tohex(meter[ff][3]) + "<p>Animid: " + tohex(animid[ff][3]) + "</p>";
			/*
			aquí ajustamos los datos que se verán en la parte de abajo a la izquierda o a la derecha
			
			ambos el jugador en pantalla y el jugador guardado de cada equipo contiene sus propios
			datos, pero sólo los del jugador en pantalla se actualizan, entonces actualizamos para
			ese jugador de cada equipo, buscando su bit de validez
			*/
			
			if(slider.value == stoppingframe){
				/*
				si el valor de stoppingframe es igual al valor del deslizador, detenemos la 
				reproducción, y regresamos stoppingframe al final de la repetición para que
				no moleste más. Stoppingframe se ajusta cuando usamos un botón de momento
				clave. Esos botones te regresan 60 fotogramas antes de que empiece el momento,
				y hace que se detenga 60 fotogramas después. Stoppingframe permite eso al
				ajustarse al valor del segundo, y comparar si esta condición se cumple, así
				es como simulamos una pequeña reproducción de momentos dentro de una repetición
				más grande
				*/
				stoppingframe = roundlist[parseInt(currround.innerHTML)] - roundlist[parseInt(currround.innerHTML) - 1] - 1;
				document.getElementById("play").innerHTML = false;
			}
			if(playbutton.innerHTML == "true") slider.value++;
			/*si se está reproduciendo, cuando terminen las funciones del fotograma, 
			agregarle 1 al valor del deslizador para moverse adelante en el siguiente 
			intervalo*/
			currframe.innerHTML = slider.value; //ajustamos el valor del fotograma visible al del deslizador
			ff = parseInt(currframe.innerHTML) + roundlist[parseInt(currround.innerHTML) - 1];
			/*
			ajustamos el valor de ff al del deslizador, más el máximo del round anterior, ya que
			ff es el valor de donde obtenemos la información de las listas como xpos, o ypos.
			Esas listas no están separadas por rounds, sino por fotogramas en conjunto, entonces
			debemos de sacar el número de fotograma absoluto para obtener los datos, en vez del
			relativo
			*/
			if(parseInt(slider.value) >= parseInt(slider.max)) playbutton.innerHTML = false;
			/*
			si el valor del deslizador es mayor o igual a su máximo, la detenmos
			porque ya acabó la reproducción
			*/
		},1000/60); //aquí ajustamos la velocidad de nuestro programa. Se ejecutará 60 veces cada segundo
	}
	
	</script>
</body>
</html>